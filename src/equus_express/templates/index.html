<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Equus Bioreactor Control System - Angular Signals</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style type="text/tailwindcss">
        @layer base {
            body {
                @apply font-sans bg-gray-900 text-white min-h-screen;
            }
            .panel {
                @apply bg-gray-800 p-6 rounded-lg shadow-lg border border-gray-700;
            }
            .input-field {
                @apply p-2 rounded-md bg-gray-700 border border-gray-600 text-white focus:outline-none focus:ring-2 focus:ring-blue-500;
            }
            .btn {
                @apply px-4 py-2 rounded-md font-semibold transition-colors duration-200;
            }
            .btn-primary {
                @apply bg-blue-600 hover:bg-blue-700 text-white;
            }
            .btn-danger {
                @apply bg-red-600 hover:bg-red-700 text-white;
            }
            .status-dot {
                @apply w-3 h-3 rounded-full mr-2;
            }
            .status-connected {
                @apply bg-green-500 animate-pulse;
            }
            .status-disconnected {
                @apply bg-red-500;
            }
        }
    </style>
</head>
<body>
    <div id="root" class="min-h-screen flex flex-col">
        <!-- Angular app will render here -->
    </div>

    <!-- Angular Core and Signals CDN -->
    <script src="https://unpkg.com/@angular/compiler@18.0.0/bundles/compiler.umd.js"></script>
    <script src="https://unpkg.com/@angular/core@18.0.0/bundles/core.umd.js"></script>
    <script src="https://unpkg.com/@angular/platform-browser@18.0.0/bundles/platform-browser.umd.js"></script>

    <!-- NATS.js CDN (for simulation, actual connection if needed) -->
    <script src="https://unpkg.com/nats.ws@1.20.0/bundles/nats.umd.js"></script>

    <script type="module">
        import { signal, computed, effect, Injector, runInInjectionContext } from 'https://unpkg.com/@angular/core@18.0.0/fesm2022/core.mjs';
        import { createApplication } from 'https://unpkg.com/@angular/platform-browser@18.0.0/fesm2022/platform-browser.mjs';

        // Helper function to generate UUID (if not using a library)
        function generateUUID() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }

        class App {
            constructor() {
                this.natsConnectionStatus = signal('Disconnected'); // 'Connected', 'Disconnected', 'Connecting'
                this.connectedDevices = signal(new Map()); // Map<UUID, Signal<telemetryData>>
                this.newMonitorId = signal('');
                this.simulationInterval = null;
                this.mockDeviceCount = 0; // To generate unique device IDs

                this.initApp();
                this.startNatsSimulation();
            }

            initApp() {
                const rootElement = document.getElementById('root');
                if (!rootElement) {
                    console.error('Root element #root not found!');
                    return;
                }

                rootElement.innerHTML = `
                    <header class="bg-gray-800 p-4 flex justify-between items-center border-b border-gray-700">
                        <div class="text-2xl font-bold text-blue-400">Equus Bioreactor Control</div>
                        <div class="flex items-center">
                            <span id="nats-status" class="flex items-center text-sm">
                                NATS: <span class="${this.natsConnectionStatus() === 'Connected' ? 'status-dot status-connected' : 'status-dot status-disconnected'}"></span>
                                <span class="font-semibold">${this.natsConnectionStatus()}</span>
                            </span>
                        </div>
                        <button class="btn btn-danger" onclick="app.emergencyStop()">ðŸ›‘ Emergency Stop</button>
                    </header>

                    <main class="flex-grow p-6 grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                        <div class="panel col-span-full">
                            <h2 class="text-xl font-bold mb-4 text-blue-400">UUID Monitor Dashboard</h2>
                            <div class="flex items-center gap-4 mb-4">
                                <input type="text" id="new-monitor-id-input" placeholder="Enter UUID to monitor" class="input-field flex-grow" oninput="app.newMonitorId.set(this.value.trim())">
                                <button class="btn btn-primary" onclick="app.addMonitor(app.newMonitorId())">Add Monitor</button>
                            </div>
                            <div id="monitors-container" class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4">
                                <!-- Monitors will be rendered here dynamically -->
                            </div>
                        </div>

                        <div class="panel">
                            <h2 class="text-xl font-bold mb-4 text-blue-400">Simulated Controls</h2>
                            <button class="btn btn-primary w-full mb-2" onclick="app.addSimulatedDevice()">Add Simulated Device</button>
                            <button class="btn btn-danger w-full" onclick="app.removeRandomSimulatedDevice()">Remove Random Device</button>
                        </div>
                    </main>
                `;

                // Initial render of NATS status (using effect for updates)
                effect(() => {
                    const statusText = this.natsConnectionStatus();
                    const statusElement = document.getElementById('nats-status');
                    if (statusElement) {
                        const dot = statusElement.querySelector('.status-dot');
                        const text = statusElement.querySelector('span:last-child');
                        if (dot && text) {
                            dot.className = `status-dot ${statusText === 'Connected' ? 'status-connected' : 'status-disconnected'}`;
                            text.textContent = statusText;
                        }
                    }
                });

                // Effect to manage monitor DOM elements based on 'connectedDevices' signal
                effect(() => {
                    const devicesMap = this.connectedDevices();
                    const container = document.getElementById('monitors-container');
                    if (!container) return;

                    // Clear existing monitors
                    container.innerHTML = '';

                    // Add/update monitors
                    devicesMap.forEach((telemetrySignal, uuid) => {
                        const monitorDiv = document.createElement('div');
                        monitorDiv.id = `monitor-${uuid}`;
                        monitorDiv.className = 'panel flex flex-col';
                        monitorDiv.innerHTML = `
                            <div class="font-bold text-lg text-blue-300 truncate" title="${uuid}">${uuid}</div>
                            <div class="flex-grow mt-2 text-sm text-gray-300">
                                <p>Temp: <span id="temp-${uuid}">--</span>Â°C</p>
                                <p>pH: <span id="ph-${uuid}">--</span></p>
                                <p>Volume: <span id="volume-${uuid}">--</span>L</p>
                            </div>
                            <button class="btn btn-danger mt-4 self-end text-xs py-1" onclick="app.removeMonitor('${uuid}')">Unsubscribe</button>
                        `;
                        container.appendChild(monitorDiv);

                        // Use a nested effect to update individual monitor's telemetry
                        // This uses an injection context to link the effect's lifecycle to the main app
                        runInInjectionContext(this.appInjector, () => {
                            effect((onCleanup) => {
                                const data = telemetrySignal();
                                if (data) {
                                    document.getElementById(`temp-${uuid}`).textContent = data.temperature !== undefined ? data.temperature.toFixed(1) : '--';
                                    document.getElementById(`ph-${uuid}`).textContent = data.pH !== undefined ? data.pH.toFixed(1) : '--';
                                    document.getElementById(`volume-${uuid}`).textContent = data.volume !== undefined ? data.volume.toFixed(1) : '--';
                                }
                                onCleanup(() => {
                                    console.log(`Cleaning up effect for ${uuid}`);
                                });
                            }, { injector: this.appInjector }); // Ensure cleanup when app is destroyed, or when monitor is removed explicitly
                        });
                    });
                }, { injector: this.appInjector }); // Link this effect to the app's injector for proper cleanup
            }

            async startNatsSimulation() {
                this.natsConnectionStatus.set('Connecting');
                // Simulate NATS connection
                await new Promise(resolve => setTimeout(resolve, 1500));
                this.natsConnectionStatus.set('Connected');

                // Simulate incoming telemetry from various devices
                this.simulationInterval = setInterval(() => {
                    // Update existing devices
                    this.connectedDevices().forEach((telemetrySignal, uuid) => {
                        this.updateSimulatedTelemetry(telemetrySignal);
                    });
                }, 1000); // Update every 1 second
            }

            updateSimulatedTelemetry(telemetrySignal) {
                const current = telemetrySignal();
                const newTemp = (current.temperature || 30) + (Math.random() * 1 - 0.5);
                const newPh = (current.pH || 6.5) + (Math.random() * 0.1 - 0.05);
                const newVolume = (current.volume || 1.0) + (Math.random() * 0.02 - 0.01);
                telemetrySignal.set({
                    temperature: Math.max(20, Math.min(50, newTemp)),
                    pH: Math.max(5, Math.min(8, newPh)),
                    volume: Math.max(0.1, Math.min(10.0, newVolume))
                });
            }

            addMonitor(uuid) {
                if (!uuid) {
                    alert('Please enter a UUID.');
                    return;
                }
                if (this.connectedDevices().has(uuid)) {
                    alert(`Monitor for UUID ${uuid} already exists.`);
                    return;
                }

                const newTelemetrySignal = signal({}); // Initial empty telemetry
                this.connectedDevices.update(map => {
                    map.set(uuid, newTelemetrySignal);
                    return new Map(map); // Create a new Map to trigger signal update
                });
                console.log(`Added monitor for UUID: ${uuid}`);
                document.getElementById('new-monitor-id-input').value = ''; // Clear input
                this.newMonitorId.set(''); // Clear signal value
            }

            removeMonitor(uuid) {
                this.connectedDevices.update(map => {
                    map.delete(uuid);
                    return new Map(map); // Create a new Map to trigger signal update
                });
                console.log(`Removed monitor for UUID: ${uuid}`);
            }

            addSimulatedDevice() {
                this.mockDeviceCount++;
                const newUuid = `simulated-device-${this.mockDeviceCount}-${generateUUID().slice(0, 8)}`;
                this.addMonitor(newUuid);
                console.log(`Simulated device added: ${newUuid}`);
            }

            removeRandomSimulatedDevice() {
                const deviceUuids = Array.from(this.connectedDevices().keys());
                const simulatedDevices = deviceUuids.filter(uuid => uuid.startsWith('simulated-device-'));

                if (simulatedDevices.length > 0) {
                    const randomIndex = Math.floor(Math.random() * simulatedDevices.length);
                    const uuidToRemove = simulatedDevices[randomIndex];
                    this.removeMonitor(uuidToRemove);
                } else {
                    alert('No simulated devices to remove!');
                }
            }

            emergencyStop() {
                if (confirm('Are you sure you want to perform an emergency stop? This will halt all processes.')) {
                    alert('Emergency stop activated. All processes halted.');
                    console.log('Emergency stop activated.');
                    // In a real app, send API call or NATS message for emergency stop
                }
            }
        }

        // Bootstrap the Angular application manually
        let appInstance;
        createApplication().then(app => {
            appInstance = new App();
            appInstance.appInjector = app.injector; // Store injector for effects
            window.app = appInstance; // Make app instance globally accessible for inline event handlers
            console.log('Angular app bootstrapped.');
        }).catch(err => console.error('Angular app bootstrap error:', err));

        // Cleanup on page unload
        window.addEventListener('beforeunload', function() {
            if (appInstance && appInstance.simulationInterval) {
                clearInterval(appInstance.simulationInterval);
            }
            // Add any other cleanup for NATS connections here
        });

    </script>
</body>
</html>
